<!doctype html>
<html lang="en-US">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<link
			rel="stylesheet"
			href="/styles.e25d0c0da0b74b34741dc7d356fd696df7bac3d9ea98f991c64fcca927461d68.css"
			type="text/css"
		/>
		<link
			rel="icon"
			href="/favicon.1d9d66e8e0f6f92db8c49e54f947c1f74da9a1a71ab0a0749fb43679df437515.svg"
			type="image/svg+xml"
		/>
		<script src="/js/load-fonts-80172701399a929f98052a2d5f34ddd0b184f6811c3180a90953e69f6880aef1.js"></script>

		<title>How to find the best software for you - anthesis</title>

		<meta name="color-scheme" content="light dark" />

		<link rel="alternate" type="application/atom+xml" href="/rss.xml" />
	</head>
	<body>
		<header>
			<nav class="navbar">
				<ul>
					<li><a href="/" hreflang="en">Home</a></li>
					<li><a href="/contact.html" hreflang="en">Contact</a></li>
					<li><a href="/src.html" hreflang="en">Source code</a></li>
				</ul>
			</nav>
		</header>
		<h1 id="how-to-find-the-best-software-for-you">
			How to find the best software for you
		</h1>
		<p>Published: <time datetime="2024-02-14">February 14th, 2024</time></p>
		<p>
			Last updated: <time datetime="2024-08-19">August 19th, 2024</time>
		</p>
		<p>
			With software, there can be so many choices that figuring out where
			to start is less easy than it could be, let alone deciding which
			project fits your needs best. In my experience, finding good quality
			software is usually a matter of taking a moment to ask the right
			questions and look in the right places.
		</p>
		<p>
			One important thing to remember is that it&#8217;s best to not let
			perfect get in the way of good enough. The best software for you is
			whatever allows you to achieve your goals while meeting your
			requirements.
		</p>
		<p>
			With that said, there&#8217;s also no reason to let adequate get in
			the way of even better.
		</p>
		<p>
			Also, note that I rarely ever go through this formal of a process.
			Think of it as a collection of ideas that I wanted to organize.
		</p>
		<h2 id="table-of-contents">Table of contents</h2>
		<ul>
			<li>
				<a href="#whats-your-use-case-for-the-software"
					>What&#8217;s your use case for the software?</a
				>
				<ul>
					<li>
						<a href="#questions-to-determine-your-software-use-case"
							>Questions to determine your software use case</a
						>
					</li>
				</ul>
			</li>
			<li>
				<a href="#what-are-some-methods-to-find-software"
					>What are some methods to find software?</a
				>
			</li>
			<li>
				<a href="#what-are-some-ways-to-compare-software-projects"
					>What are some ways to compare software projects?</a
				>
				<ul>
					<li>
						<a href="#how-to-review-open-source-repositories"
							>How to review open source repositories</a
						>
					</li>
					<li>
						<a href="#other-things-to-review-and-ask"
							>Other things to review and ask</a
						>
					</li>
				</ul>
			</li>
		</ul>
		<h2 id="whats-your-use-case-for-the-software">
			What&#8217;s your use case for the software?
		</h2>
		<p>
			There&#8217;s plenty of software out there, but whether it&#8217;ll
			be useful to you somewhat depends on if it fits your use case.
			Here&#8217;s a list of questions that could be helpful for
			determining exactly what you&#8217;re looking for in software.
		</p>
		<h3 id="questions-to-determine-your-software-use-case">
			Questions to determine your software use case
		</h3>
		<ul>
			<li>
				<p>
					What problem will the software solve? If it&#8217;s going to
					replace a prior solution, what about the previous approach
					didn&#8217;t work and what needs to be different this time?
					A good understanding of these things is foundational for
					everything else. At its core, the process of choosing
					software is about finding what would solve a problem you
					have.
				</p>
			</li>
			<li>
				<p>
					Is it possible to break that problem down into smaller ones
					so that specialized tools can handle each part more
					effectively? Sometimes you may not even need another
					application and can handle it with the programs you already
					have, especially if you&#8217;re good at shell scripting.
				</p>
			</li>
			<li>
				<p>
					Who are the target users and what are their requirements?
					Consider their accessibility requirements and whether the
					program will be usable for them. User interface (UI) and
					user experience (UX) considerations most likely fall under
					this category as well.
				</p>
			</li>
			<li>
				<p>
					What functionality is needed? Let&#8217;s say you have a
					list of web pages and need to take a screenshot of each one.
					A utility that only checks if those websites are still
					online may be useful for other reasons, but it won&#8217;t
					do everything you need it to on its own. You might also need
					some features related to tool integration, like the ability
					to work with certain data formats (JSON, XML), databases
					(SQL, NoSQL), APIs, or other common data exchange systems
					(standard input and standard output are among my favorites).
				</p>
			</li>
			<li>
				<p>
					What functionality <em>isn&#8217;t</em> needed? The simpler
					a piece of software is, the less places there are in the
					code for bugs to exist; from experience, it can be wise to
					choose something with enough features to comfortably
					accomplish your end goal. Perhaps you&#8217;re thinking of
					creating a blog written in Markdown, one that doesn&#8217;t
					need dynamic elements like JavaScript or PHP. With this in
					mind, you could eliminate complex content management systems
					and start looking at static site generators or
					Markdown-to-HTML converters instead.
				</p>
			</li>
			<li>
				<p>
					What operating system(s) and&#47;or environments does the
					software need to be compatible with? Software is generally
					more useful when you can actually install and run it. Though
					something to keep in mind is that you can often deploy
					programs in a container or virtual machine if needed (or you
					could try porting it to your platform, if you feel like
					doing that).
				</p>
			</li>
			<li>
				<p>
					What are your privacy and security requirements? To give a
					meaningful answer, you need to know the answer to this
					question first: what&#8217;s your threat model?
					There&#8217;s little sense in assuming that something is
					private or secure without a threat model, since it&#8217;s
					unknown what it&#8217;s secured against or what&#8217;s kept
					private from whom. Thinking about these things will help you
					protect your assets more effectively and could save you some
					headaches.
				</p>
			</li>
			<li>
				<p>
					Do you have any preferences or requirements when it comes to
					software licensing, source code availability, and things of
					this nature? Here are some examples of where the differences
					between open source licenses in particular can be important
					to think about.
				</p>
				<ul>
					<li>
						Perhaps you need to incorporate some open source code
						into proprietary software, or maybe you favor ease of
						adoption. In this case, something with a permissive
						license could work well (MIT, BSD, ISC, etc).
					</li>
					<li>
						If you feel strongly that source code, including any
						derivative works, should always remain open to all, then
						you may want to consider a copyleft license (GPL, AGPL,
						MPL, etc).
					</li>
				</ul>
			</li>
			<li>
				<p>
					What other constraints do you have? These can be factors
					like performance, scalability, user support, compliance with
					standards and regulations, and so on. Knowing these things
					allows you to prioritize the options that are most likely to
					work for you.
				</p>
			</li>
		</ul>
		<h2 id="what-are-some-methods-to-find-software">
			What are some methods to find software?
		</h2>
		<p>
			Now that you have a better idea of what you need, you can start
			searching for software. There are many different ways you can go
			about this. Remember to verify that a given resource is worth
			placing your trust in before following any instructions or taking
			any advice.
		</p>
		<ul>
			<li>
				<p>
					Searching websites or applications that provide or index
					software. This is the most direct option, and it&#8217;s
					good to be familiar with them since you&#8217;ll need these
					at some point anyway. However, sometimes it can take some
					digging to figure out how to find things. Browsing topics or
					&#8220;awesome lists&#8221; on a place like GitHub can
					provide some insight into what&#8217;s available.
				</p>
			</li>
			<li>
				<p>
					Reading discussions (think forums, chatrooms, and mailing
					lists, to name a few), wikis, blogs, or other written
					resources that concern something relevant to the kind of
					software you&#8217;re looking for. You can get some good
					ideas by visiting these places and skimming through them.
				</p>
			</li>
			<li>
				<p>
					Consulting other forms of media such as videos. These tend
					to take more time, or at least they do for me. However,
					they&#8217;re still valuable and can lead to some good
					finds.
				</p>
			</li>
			<li>
				<p>
					Prompting large language models (LLMs) to brainstorm ideas
					with you, make suggestions, and explain concepts. It&#8217;s
					usually good to remain a little skeptical and fact check the
					output to make sure that it&#8217;s legitimate. Artificial
					intelligence (AI) is promising despite its current
					limitations, and I&#8217;m interested to see how it
					develops.
				</p>
			</li>
			<li>
				<p>
					Asking knowledgeable people what they use, how they found
					it, and why they chose it over the alternatives. It's likely
					that you'll get a better response from people if you ask
					good questions and show them that you value their time; in
					other words, it should be evident that you&#8217;ve already
					done some research, such as using a search engine and
					consulting other publicly available resources.
				</p>
			</li>
		</ul>
		<h2 id="what-are-some-ways-to-compare-software-projects">
			What are some ways to compare software projects?
		</h2>
		<p>
			Once you&#8217;ve found some software through trustworthy means that
			fits your use case, it raises another question: how do you decide
			between them?
		</p>
		<p>
			There are certain positive signals that can indicate that a project
			is worth keeping in mind. They don&#8217;t offer any guarantee of
			code quality; only examining the code itself can provide that. Even
			so, these have been good heuristics (rules of thumb) to follow for
			me because many of them do seem to be correlated with code quality.
		</p>
		<p>
			Though if you have sufficient time, motivation, and skill, reading
			through the source code is a good idea.
		</p>
		<h3 id="how-to-review-open-source-repositories">
			How to review open source repositories
		</h3>
		<p>
			Here are some things to take a look at when reviewing open source
			projects. Some of these are going to depend on the frontend (GitHub,
			Gitlab, etc).
		</p>
		<ul>
			<li>
				<p>
					A priority in many cases is to check the license and README,
					ensuring that everything there fits with your goals and use
					case.
				</p>
			</li>
			<li>
				<p>
					Check what programming languages are used. Are you able to
					fix or extend software written in those languages? Do you
					like something about the programming language used for one
					project more than the language used by another?
				</p>
			</li>
			<li>
				<p>
					Is there a security policy? If so, what does it say?
					Vulnerability disclosure programs, bug bounties, and regular
					audits are good things to see.
				</p>
			</li>
			<li>
				<p>
					Are best practices and standards in the industry generally
					present (tests, linters and static analysis tools,
					continuous integration and continuous delivery, conventional
					commits, semantic versioning, etc)?
				</p>
			</li>
			<li>
				<p>
					When was the project first started? Repositories that have
					been active for a while may be more likely to stick around.
				</p>
			</li>
			<li>
				<p>
					What different types of activity are happening and how
					recently have they occurred? These are ways to see if a
					project is still being actively maintained, which means
					resolution of bugs and vulnerabilities may be more likely.
					Remember that the simpler the code is, the less maintenance
					it probably needs.
				</p>
				<ul>
					<li>When was the last commit?</li>
					<li>
						How frequently does this repository get new commits in
						general?
					</li>
					<li>When was the last release?</li>
					<li>How frequently are new releases made in general?</li>
					<li>
						What other kinds of activity happened in the past month?
					</li>
				</ul>
			</li>
			<li>
				<p>
					Indicators of popularity, such as the number of stars and
					forks. But be careful with these. Fake stars and forks have
					been available for purchase in various places for a while
					now.
				</p>
				<ul>
					<li>
						One idea is to glance at the forks and see if any of
						them have significant activity. Look at the accounts
						responsible for the more popular forks and check for
						things that are more difficult to fake, like merged pull
						requests in reputable repositories that they don&#8217;t
						own.
					</li>
				</ul>
			</li>
			<li>
				<p>
					The number of people that regularly contribute. Bus factor
					is something to consider&#8212;how many people would have to
					get hit by a bus for the entire thing to stall indefinitely?
					Is that an acceptable level of risk for something you may be
					consistently using? Are you willing to maintain it yourself
					if the project suddenly goes dormant?
				</p>
			</li>
			<li>
				<p>
					Open and closed issues. Observe the ratio between them and
					apply various filters, combining them if it seems
					interesting. The manner in which problems are resolved can
					speak volumes about the level of care put into the software.
				</p>
				<ul>
					<li>
						Sort by number of comments, from greatest to least.
						These are in some way significant to the community. The
						same goes for sorting by reactions.
					</li>
					<li>
						Sort by update time, from most recent to least, as a way
						of gleaning where people&#8217;s attention is going.
					</li>
					<li>
						Any issues with interesting labels, especially those
						related to security. Closed issues with a label like
						&#8220;wontfix&#8221; or &#8220;invalid&#8221; can also
						be illuminating.
					</li>
					<li>
						Issues opened by important people, like the author of
						the repository.
					</li>
					<li>Pinned issues.</li>
				</ul>
			</li>
			<li>
				<p>
					Pull requests. Ideally, there will be a certain degree of
					scrutiny present, and yet also a willingness to accept good
					contributions. You can use many of the same sorting and
					filtering options as before.
				</p>
				<ul>
					<li>Closed pull requests, both merged and unmerged.</li>
					<li>
						Open pull requests that are linked to issues (you can do
						this the other way around, too).
					</li>
					<li>
						Are there procedures that need to be followed to
						contribute? Are pull requests reviewed by multiple
						people before merge? Both are good signs.
					</li>
				</ul>
			</li>
			<li>
				<p>
					The documentation. READMEs, manuals, official wikis and
					blogs, release notes, etc.
				</p>
				<ul>
					<li>
						How much effort has been put into the documentation? You
						could look at commits and pull requests related to this,
						but it can be determined by feel as well.
					</li>
					<li>
						Is the documentation up to date? Does it make sense to
						you?
					</li>
				</ul>
			</li>
			<li>
				<p>
					How many external dependencies does the project pull in?
					These are additional unknowns that you&#8217;re implicitly
					placing your trust in when you use the software.
					Dependencies aren&#8217;t inherently a good or bad thing, so
					much as they are another data point to consider.
				</p>
			</li>
		</ul>
		<h3 id="other-things-to-review-and-ask">
			Other things to review and ask
		</h3>
		<ul>
			<li>
				<p>
					See if you can find the project on a website that lists
					publicly disclosed vulnerabilities. What vulnerabilities
					have come up before and are there any patterns? For
					instance: does the same class of vulnerability keep cropping
					up? Are vulnerabilities typically severe with low exploit
					complexity?
				</p>
			</li>
			<li>
				<p>
					Have any security audits been performed, and are they done
					on a consistent basis? What were the results? What did the
					security researchers think of the product&#8217;s overall
					design?
				</p>
			</li>
			<li>
				<p>
					How have the developers handled vulnerabilities in the past?
					Have they been consistently transparent with their users
					when it comes to security issues?
				</p>
			</li>
			<li>
				<p>
					Do the developers cryptographically sign their releases
					and&#47;or commits to provide a greater degree of safety for
					the users?
				</p>
			</li>
			<li>
				<p>
					Can you install the software through your system&#8217;s
					package manager?
				</p>
			</li>
			<li>
				<p>
					Do some research and find other places that mention the
					software, especially community oriented ones that
					aren&#8217;t owned or moderated by the creators. What are
					other people saying about it?
				</p>
			</li>
			<li>
				<p>
					If there&#8217;s a company behind the software, what are the
					public&#8217;s impressions of that company? Are there
					indications that the company cares about its users and the
					quality of its product? Where does their money come from and
					where does it go?
				</p>
			</li>
			<li>
				<p>
					Look through any important documents, like terms of service
					and privacy policy. Is there anything interesting or out of
					place there?
				</p>
			</li>
			<li>
				<p>
					If there&#8217;s a dedicated website, is it put together in
					a logical, effective fashion? Not &#8220;do I like the
					website aesthetically speaking&#8221;, but &#8220;from an
					engineering standpoint, is this website intelligently
					designed for what it needs to do?&#8221; Plain, fast, and
					functional is a much better sign than flashy, slow, and
					nearly disintegrating.
				</p>
			</li>
			<li>
				<p>
					Is the software written in a memory-safe programming
					language?
				</p>
			</li>
			<li>
				<p>
					You can throw the software into a virtual machine you
					don&#8217;t use for anything else and run it to study its
					behavior.
				</p>
			</li>
		</ul>
	</body>
</html>
